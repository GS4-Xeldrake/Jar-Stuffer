#------------------------------------------------------------------------------
# AUTHOR           : Xeldrake the sorcerer (aka: Nips the wizard)
# CREATED DATE     : 20 DEC 2018
# PROGRAM NAME     : xjars.lic
# PURPOSE          : Take a whitelist of item, either gems or reagents
#                    and store them into jars.
#
# FEATURES         : Uses partial jars prior to filling empties
#                  : Combine varying pearl sizing in one jar
#                  : Stashing full jars in desired containers
#                  : An inventory component to track all jars with gems
#
# REVISION HISTORY :
#
# DATE:     AUTHOR:         REF:        REVISION (DATE IN YYYYMMDD FORMAT)
# 20181223  Xeldrake        v1.0        (Alpha)
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# TODOs
#------------------------------------------------------------------------------

# TODO comma separate add= param and remove recurrences
# TODO add buying option for empties
# TODO get the downstream hook working for 'inv full'
# TODO implement "list" parameter
# TODO buy empties
# TODO sort types

#------------------------------------------------------------------------------
# Globals
#------------------------------------------------------------------------------

$debug = true

#------------------------------------------------------------------------------
# Per character settings
#------------------------------------------------------------------------------

CharSettings['whitelist']      = []     if CharSettings['whitelist'].nil?
CharSettings['combine_pearls'] = false  if CharSettings['combine_pearls'].nil?
CharSettings['full_jar_bag']   = false  if CharSettings['full_jar_bag'].nil?
CharSettings['buy_empties']    = false  if CharSettings['buy_empties'].nil?
CharSettings['type_ahead']     = 1      if CharSettings['type_ahead'].nil?
CharSettings['premium']        = nil    if CharSettings['premium'].nil?

whitelist = CharSettings['whitelist'].dup

#------------------------------------------------------------------------------
#  Modules
#------------------------------------------------------------------------------

module DownstreamHooks

  def self.auto_stop(stop_match, command, hook_name, output_lines = true, capture_hashes = {})
    # Will output all but captures_hashes when output_lines = true
    # OR globally squelch all output lines and can always return captures from hashes
    # will stop hook when the regex value matches the line you want to
    # stop on. Ensure that you know the underlying XML pattern to match or the
    # hook will remain active

    job_complete = false   # once this is true, exit the hook
    captures     = []      # return value if captures

    DownstreamHook.add(hook_name, Proc.new do |line|

      # keep hook going until stop match
      if line =~ stop_match
        DownstreamHook.remove(hook_name)
        job_complete = true
      end

      hash_match = false

      # there were pattern, check each value to possibly squelch
      capture_hashes.each_pair do |key, value|

        # if there's a match, break out and set match to true
        if line =~ value
          result = value.match(line)
          captures << result
          hash_match = true
          nil
          break
        end

      end # end each pair

      next if hash_match == true

      next line if output_lines == true

    end # end proc parameter
    )

    # silence commands
    silence_me

    # run a command and hook
    fput command

    # wait for a stop line pattern
    wait_until{job_complete}

    # un-silence
    silence_me

    # return the pattern that was used as the stop match
    return captures

  end # end method

end

#------------------------------------------------------------------------------

module Jarrables

  def set_jarable_gems
    @jarable_gems = /
      (:?swirling\saetherstone|Kezmonian\shoney\sberyl|banded\sagate|blue\slace\sagate|chameleon\sagate
      |cloud\sagate|fire\sagate|frost\sagate|moss\sagate|mottled\sagate|tigereye\sagate
      |droplet\sof\shoney\samber|piece\sof\sgolden\samber|teardrop\sof\sgreen\samber
      |polished\sdark\sblue\samber|deep\spurple\samethyst|shadow\samethyst
      |brilliant\swyrm's-tooth\samethyst|smoky\samethyst|shifting\smultihued\sauboraline
      |piece\sof\sazurite|spar\sof\spocked\sazurite|Kezmonihoney\sberyl
      |formation\sof\srainbowed\sbismuth|azure\sblazestar|crimson\sblazestar
      |emerald\sblazestar|golden\sblazestar|selanthbloodjewel|dark\sred-green\sbloodstone
      |bright\sbluerock|deep\sred\scarbuncle|chunk\sof\ssand-smoothed\schalcedony
      |piece\sof\sgrey\schalcedony|piece\sof\swhite\schalcedony
      |radiant\sgreen\scinderstone|piece\sof\sblue\sridge\scoral|polished\sblack\scoral
      |polished\sblue\scoral|polished\spink\scoral|polished\sred\scoral|blue\scordierite
      |piece\sof\scorestone|cinnabar\scrystal|dull\sgrey\scrystal|glaesine\scrystal
      |pink\ssalt\scrystal|quartz\scrystal|rock\scrystal|shard\sof\sdragonmist\scrystal
      |shard\sof\stigerfang\scrystal|tangerine\swulfenite\scrystal|chalky\syellow\scube
      |black\sdeathstone|scarlet\sdespanal|blue\sdiamond|dragon's-tear\sdiamond
      |dwarf-cut\sdiamond|faceted\sblack\sdiamond|large\syellow\sdiamond|uncut\sdiamond
      |uncut\smaernstrike\sdiamond|uncut\sstar-of-Tamzyrr\sdiamond
      |white-point\sstar\sdiamond|star\sdiopside|glossy\sblack\sdoomstone
      |black\sdreamstone|blue\sdreamstone|green\sdreamstone|pink\sdreamstone
      |red\sdreamstone|yellow\sdreamstone|white\sdreamstone|dram\sof\sgold\sdust
      |handful\sof\sgold\sdust|pinch\sof\sgold\sdust|petrified\saivren\segg
      |dragonfire\semerald|dragon's-tear\semerald|dwarf-cut\semerald|uncut\semerald
      |star\semerald|Eye-of-Koar\semerald|deep\sblue\seostone|milky\squartz\seye|obsidieye
      |olivine\sfaenor-bloom|bronze\sfang|copper\sfang|gold\sfang|iron\sfang|mithril\sfang
      |platinum\sfang|silver\sfang|steel\sfang|urglaes\sfang|cube\sof\schalky\sfeldspar
      |bright\sviolet\sfeystone|periwinkle\sfeystone|firestone|piece\sof\sstriated\sfluorite
      |silvery\sgalena|almandine\sgarnet|blood\sred\sgarnet|dark\spurple\ssunset\sgarnet
      |green\sgarnet|orange\sspessartine\sgarnet|sanguine\swyrm's-eye\sgarnet|ametrine\sgem
      |aquamarine\sgem|bright\schrysoberyl\sgem|clear\sblue\sgem|fiery\sred\sgem
      |flawless\saquamarine\sgem|golden\sberyl\sgem|green\schrysoprase\sgem
      |small\sgreen\sgeode|small\sblue\sgeode|small\sred\sgeode|small\spurple\sgeode
      |brilliant\slilac\sglimaerstone|ceruleglimaerstone|clear\sglimaerstone
      |golden\sglimaerstone|green\sglimaerstone|peach\sglimaerstone|smoky\sglimaerstone
      |ultramarine\sglimaerstone|oblong\sblue\sgoldstone|rosette\sof\scrystalline\sgypsum
      |shard\sof\scloudy\sgypsum|piece\sof\spetrified\shaon|pale\syellow\sheliodor
      |orb\sof\smirrored\shematite|spar\sof\sdull\shematite|sphere\sof\sscratched\shematite
      |yellow\shyacinth|blackish\sblue\sidocrase|piece\sof\spolished\sivory
      |age-darkened\sivory\screscent|fiery\sjacinth|piece\sof\sbrown\sjade|piece\sof\sgreen\sjade
      |piece\sof\swhite\sjade|piece\sof\syellow\sjade|cone\sof\sember\sjasper
      |nodule\sof\speacock\sjasper|ovoid\sof\sleopard\sjasper|ovoid\sof\slunar\sjasper
      |ovoid\sof\smonsoon\sjasper|pebble\sof\sorbicular\sjasper|piece\sof\sblack\sjasper
      |piece\sof\sred\sjasper|piece\sof\syellow\sjasper|blue\slapis\slazuli
      |piece\sof\spetrified\smaoral|piece\sof\sblack\smarble|piece\sof\sgreen\smarble
      |piece\sof\spink\smarble|piece\sof\swhite\smarble|piece\sof\sblood\smarble
      |nodule\sof\sshimmering\smarcasite|glossy\spale\sbeige\smekret|glossy\ssable\smekret
      |large\spiece\sof\smica|chunk\sof\sdark\smica|blue\smoonstone|grey\smoonstone
      |cats-eye\smoonstone|black\smoonstone|golden\smoonstone|opaline\smoonstone
      |pale\sblue\smoonstone|pale\sgreen\smoonstone|silvery\smoonstone
      |piece\sof\soblong\snephrite|gold\snugget|platinum\snugget|large\sgold\snugget
      |large\splatinum\snugget|piece\sof\sjet\sblack\sobsidian|piece\sof\sspiderweb\sobsidian
      |piece\sof\sbanded\sonyx|piece\sof\sblack\sonyx|aster\sopal|black\sopal
      |blue\sgreen\slagoon\sopal|blue\ssky\sopal|boulder\sopal|cluster\sof\sfire\sopal
      |dragonfire\sopal|fire\sopal|moonglae\sopal|white\sopal|blue-white\sfrost\sopal
      |brilliant\spurple\sopal|purple\sblack\sthunderhead\sopal|green\sora-bloom
      |black-cored\semerald\sorb|golden\sfiremote\sorb|murky\sshadowglass\sorb
      |brilliant\sfire\spearl|iridescent\spearl|metallic\sblack\spearl|midnight\sblue\spearl
      |tiny\sblack\spearl|tiny\sgrey\spearl|tiny\spink\spearl|tiny\swhite\spearl
      |small\sblack\spearl|small\sgrey\spearl|small\spink\spearl|small\swhite\spearl
      |medium\sblack\spearl|medium\sgrey\spearl|medium\spink\spearl|medium\swhite\spearl
      |large\sblack\spearl|large\sgrey\spearl|large\spink\spearl|large\swhite\spearl
      |pink\speridot|green\speridot|blue\speridot|hunk\sof\shole-ridden\spumice
      |pyrite|piece\sof\sblue\squartz|cluster\sof\sirregular\sblue\squartz
      |piece\sof\scarneliquartz|piece\sof\scat's\seye\squartz|piece\sof\scitrine\squartz
      |piece\sof\srose\squartz|quartz\scrystal|shard\sof\srainbow\squartz
      |tangerine\squartz|asterfire\squartz|dragonfire\squartz|dragon's-fang\squartz
      |leopard\squartz|shard\sof\soblivion\squartz|golden\srhimar-bloom
      |blue\sstar-shaped\sriftshard|faceted\smidnight\sblue\sriftstone|pale\sviolet\sriftstone
      |piece\sof\sblack\sriftstone|Alhan'aht\srivertear|square\sof\sshale\srock
      |cluster\sof\sorange\sroestone|cluster\sof\sred\sroestone|piece\sof\srosespar
      |dragon's-tear\sruby|dwarf-cut\sruby|faceted\sblood\sred\ssandruby
      |impure\sblood\sred\sruby|star\sruby|uncut\sruby|sylvarraend\sruby
      |jewel-toned\sdragonfly\ssaewehna|bright\sorange\sbutterfly\ssaewehna
      |iridescent\sazure\sbutterfly\ssaewehna|pale\sgold\sfirefly\ssaewehna
      |silver\sfirefly\ssaewehna|vibrant\shummingbird\ssaewehna
      |russet\sand\scream\smoth\ssaewehna|silvery\smint\sgreen\smoth\ssaewehna
      |alabaster\ssandsilver|blue\ssapphire|blue\sshimmarglin\ssapphire
      |clear\ssapphire|dragonsbreath\ssapphire|dragonseye\ssapphire
      |deep\sblue\smermaid's-tear\ssapphire|dwarf-cut\ssapphire|green\ssapphire
      |lavender\sshimmarglin\ssapphire|pale\smistvein\ssapphire|pale\soasis\ssapphire
      |pale\swater\ssapphire|pink\ssapphire|star\ssapphire|violet\ssapphire
      |yellow\ssapphire|umber\ssard|blood\sred\steardrop-etched\sscarab
      |etched\stranslucent\sscarab\sscarab|glimmering\sopalescent\sscarab
      |sea-green\sglaes\sscarab|sky-blue\sglaes\sscarab|spiked\sonyx\sscarab
      |round\sdisk\sof\shazy\sred\sseglass|round\sdisk\sof\smist\sblue\sseglass
      |round\sdisk\sof\samber\sseglass|round\sdisk\sof\sgreen\sseglass
      |cloudy\salexandrite\sshard|shimmertine\sshard|swirled\slightning\sglass\sshard
      |amethyst\sclam\sshell|angulate\swentletrap\sshell|beige\sclam\sshell
      |black-spined\sconch\sshell|blue-banded\scoquinshell|bright\snoble\spectin\sshell
      |blue\speriwinkle\sshell|candystick\stellin\sshell|checkered\schiton\sshell
      |crown\sconch\sshell|crown-of-Charl\sshell|dovesnail\sshell|egg\scowrie\sshell
      |fluted\slimpet\sshell|golden\scowrie\sshell|piece\sof\siridescent\smother-of-pearl
      |large\schipped\sclam\sshell|large\smoonsnail\sshell|lavender\snassshell
      |leopard\scowrie\sshell|lynx\scowrie\sshell|marlin\sspike\sshell
      |multi-colored\ssnail\sshell|opaque\sspiral\sshell|pearl\snautilus\sshell|pink\sclam\sshell
      |pink-banded\scoquinshell|polished\sbatwing\schiton\sshell|polished\sblack\stegulshell
      |purple-cap\scowrie\sshell|ruby-lined\snassshell|seurchin\sshell|silvery\sclam\sshell
      |snake-head\scowrie\sshell|snow\scowrie\sshell|Solhaven\sBay\sscallop\sshell
      |sparkling\ssilvery\sconch\sshell|speckled\sconch\sshell|spiny\ssiren's-comb\sshell
      |spiral\sturret\sshell|split-back\spink\sconch\sshell|striated\sabalone\sshell
      |sundial\sshell|three-lined\snassshell|tiger\scowrie\sshell|tiger-striped\snautilus\sshell
      |translucent\sgolden\sspiral\sshell|yellow-banded\scoquinshell|white\sgryphon's\swing\sshell
      |white\sclam\sshell|scarlet\ssmoldereye|violet\ssmoldereye|fiery\sviridisoulstone
      |black\ssphene|brown\ssphene|white\ssphene|yellow\ssphene|tiny\sblack\sand\sblue\sspherine
      |tiny\sgreen\sand\sgrey\sspherine|tiny\sred\sand\sblue\sspherine
      |tiny\swhite\sand\sblack\sspherine|transparent\sspherine|blue\sspinel|pink\sspinel
      |red\sspinel|violet\sspinel|fossilized\sbessho\slizard\sspur|blue\sstarstone
      |green\sstarstone|red\sstarstone|white\sstarstone|banded\ssardonyx\sstone
      |blue-green\schrysocollstone|brilliant\sred\sfirebird\sstone|chunk\sof\spale\sblue\sice\sstone
      |chunk\sof\spearly\sgrey\sice\sstone|chunk\sof\ssnowy\swhite\sice\sstone|dark\sblue\stempest\sstone
      |ebon-cored\svortex\sstone|faint\sgold\stempest\sstone|green\salexandrite\sstone
      |green\saventurine\sstone|green\smalachite\sstone|iridescent\slabradorite\sstone
      |light\spink\smorganite\sstone|pale\sgrey\stempest\sstone|pink\srhodochrosite\sstone
      |polished\sjet\sstone|silver-cored\svortex\sstone|turquoise\sstone|red\ssunstone
      |white\ssunstone|yellow\ssunstone|jet-banded\samber\ssunstone|uncut\ssunstone
      |deep\sblue\ssapphire\stalon|fiery\sred\sruby\stalon|glistening\sonyx\stalon
      |sparkling\semerald\stalon|variegated\sviolet\stanzanite|piece\sof\spetrified\sthanot
      |deep\sblue\sthunderstone|radiant\sopalescent\sthunderstone|smoky\sgrey\sthunderstone
      |swirling\spurple\sthunderstone|polished\sshark\stooth|petrified\stoadstool|blue\stopaz
      |clear\stopaz|golden\stopaz|green\serrisitopaz|orange\simperial\stopaz|Phoen's\seye\stopaz
      |pink\stopaz|smoky\stopaz|black\stourmaline|blue\stourmaline|clear\stourmaline|green\stourmaline
      |pink\stourmaline|spiderweb\sturquoise|petrified\smammoth\stusk|argent\svultite-bloom
      |nacreous\sblue\swaterweb|dark-spoked\scrystalline\swheel|small\scrystal-spoked\swheel
      |crystal\sof\sshadowy\swraithaline|crystal\sof\ssilvery\swraithaline|multi-colored\swyrdshard
      |brown\szircon|clear\szircon|green\szircon|snowflake\szircon|yellow\szircon)(?=$)
    /x
  end

  def set_ingredients
    @ingredients = /
      (:?acantha\sleaf|lump\sof\sblack\sambergris|almandine\sgarnet|aloeas\sstem|ambrominas\sleaf|ayana\sleaf|ayanad\scrystal
      |basal\smoss\s|black\sjasper|black\ssphene|black\stourmaline|blood\sred\sgarnet|bloodwood\stwig
      |blue\slapis\slazuli|blue\spoppy|blue\ssapphire|blue\strafel\smushroom|blue\stourmaline
      |boar\stusk\sfrom\sgreat\sboars|bolmara\slichen\s|bright\sbluerock|bright\schrysoberyl\sgem
      |brostheras\sgrass|brown\sjade|brown\ssphene|bur-clover\sroot\s|cactacae\sspine\s|calamia\sfruit
      |cat's\seye\smoonstone|centaur\shide\sfrom\scentaurs|citrine\squartz|clear\stopaz|clear\szircon
      |cloudy\scrystal|coarse\sglittering\searth|coarse\sivory\sdust|cockatrice\splume\sfrom\s
      |concentrated\sfirethorn\sessence|corked\scrystalline\sglobe\sfilled\swith\sglowing\smineral\swater
      |cracked\ssoulstone|crimson\sdragonstalk|crushed\sskeletal\sgiant\sbone\sfrom\sskeletal\sgiants
      |crystal\score|crystal\score\sessence|crystalline\ssolution|cuctucae\sberry\s
      |cyclops\seye\sfrom\sa\scyclops|dark\sglittering\spowder|dark\sshadow-shrouded\scrystal|deep\sblue\seostone
      |ebony\stwig|elemental\score|ephlox\smoss\s|essence\sof\sair|essence\sof\searth|essence\sof\sfire
      |essence\sof\sregeneration|essence\sof\svitality|essence\sof\swater|faintly\sglimmering\sdust
      |faintly\sglowing\sdust|faintly\sglowing\sworm\sskin|faintly\sradiant\sdust|faintly\sshimmering\sdust
      |fairy\sprimrose|fiery\sjacinth|fire\scat\sclaw\sfrom\sfire\scats|genkew\smushroom
      |ghoul\sfinger\sfrom\sghoul\smasters|ghoul\snail\sfrom\slesser\sghouls|giant\sglowing\stoadstool
      |giant\sskin\sfrom\sstorm\sgiants|glimmering\sblue\sessence\sdust|glimmering\sblue\sessence\sshard
      |glimmering\sblue\smote\sof\sessence|glistening\sblack\seye\sfrom\sdark\sshamblers
      |glossy\sblack\sdoomstone|glowing\sviolet\sessence\sdust|glowing\sviolet\sessence\sshard
      |glowing\sviolet\smote\sof\sessence|glowing\sfirefly|glowing\smote\sof\sessence
      |goat\shoof\sfrom\smountain\sgoats|gold\sdust|golden\samber|golden\saster|golden\sberyl\sgem
      |golden\smoonstone|golden\stopaz|golem\sbone\sfrom\sbone\sgolems|green\sgarnet|green\ssapphire
      |green\sstarstone|green\stourmaline|haphip\sroot\s|heath\saster|inky\snecrotic\score
      |iridescent\spiece\sof\smother-of-pearl|iron\sdust|jagged\scrimson\scrystal|jagged\stranslucent\scrystal
      |luckbloom\sblossom|lump\sof\sgrey\sambergris|marallis\sberry|mottled\sfaeroth\screst|myklian\sscale
      |n'ayanad\scrystal|nightbloom\sblossom|oak\stwig|orange\sspessartine\sgarnet|orc\sknuckle
      |pale\sblue\sruned\scrystal\sshard|pale\stranslucent\sdust|pepperthorn\sroot|pink\srhodochrosite\sstone
      |pink\stopaz|plains\slion\sskin\sfrom\splains\slions|polished\spink\scoral|pothinir\sgrass|powder\ssolution
      |powdered\sgrey\spearl|powdered\srock\scrystal|powdered\sturqoise\sstone|powdered\swhite\sopal
      |powdered\swhite\spearl|powdered\swraith\stalon\sfrom\swraiths|pristine\snymph's\shair
      |pristine\ssiren's\shair|pure\soil|quartz\ssand|radiant\scrimson\sessence\sdust
      |radiant\scrimson\sessence\sshard|radiant\scrimson\smote\sof\sessence|rainbow\squartz
      |red\strafel\smushroom|rose\squartz|rose-marrow\spotion\sroot\s|runed\scrimson\scrystal
      |s'ayanad\scrystal|scraggly\sorc\sscalp\sfrom\s|sea\ssalt|shelfae\screst\sfrom\s
      |shimmering\sprismatic\sshard|shimmertine\sshard|silver\smane|silvery\shoof|silvery\stail
      |skeletal\sgiant\sbone\sfrom\s|skeleton\sbone\sfrom\sskeletons|slender\stwig|slender\swhite\sbone
      |small\sdaisy|small\senruned\sbone|small\stroll\stooth|smoky\sglimaerstone|smoky\stopaz|smooth\sstone
      |snake-head\scowrie\sshell|soft\sblue\sgriffin\sfeather|soft\swhite\smushroom|sovyn\sclove\s
      |sparkling\ssilvery\sconch\sshell|spotted\sleopard\spelt|sprig\sof\sfoxglove|sprig\sof\sholly
      |sprig\sof\slarkspur|sprig\sof\slavender|star\sruby|star\ssapphire|stargazer\slily|sunburst\sblossom
      |sweetfern\sstalk\s|t'ayanad\scrystal|talneo\sroot\s|tiny\sgolden\sseed|tkaro\sroot\s|torban\sleaf
      |tree\sviper\sfang\sfrom\stree\svipers|trinket\soil|troll\sskin\sfrom\scave\strolls|twisted\stwig
      |turqoise\sstone|ursian\stusk|valerian\sroot|vial\sof\saelotoi\stears|vial\sof\ssea\swater
      |violet\ssapphire|violet\sIthzir\sbezoar|viper\sfang\sfrom\sblack\sforest\svipers|wand\soil
      |warcat\swhisker\sfrom\sstriped\swarcats|wavepetal\sblossom|wheat\sgrass|white\shook\smushroom
      |wight\sskin\sfrom\sarch\swights|wingstem\sroot\s|wolifrew\slichen\s|woth\sflower|yabathilium\sfruit
      |yellow\ssapphire|yellowed\sboar\stusk\sfrom\smassive\sblack\sboars|yew\stwig)(?=$)
    /x
  end

end

#------------------------------------------------------------------------------
#  Classes
#------------------------------------------------------------------------------

class Param_parser
  include Jarrables

  VALID_COMMANDS = %w(
    add remove help list inv
    full-jar-bag sort-fulls
    combine-pearls buy-empties type-ahead)

  attr_reader :state

  def initialize(params, script_name)
    @params       = params[0]
    @param_values = []
    @sn           = script_name
    @state        = nil

    process_params(@params)
  end

  def process_params(param)
    @param_values

    pat_param = /(?<param>([a-zA-Z-])+(?=\=)  # all word chars with hyphen
                                              # followed by an '='
                                              # e.g., num-add=, or something=
                 |(?<=^|\s)
                 (help|list|inv)(?=\s|$))=?       # or match the word 'help', etc
    /x

    pat_value = /(?<value>([a-zA-Z0-9\'\-]+   # grab all word or number chars
                 (\s(?!help|list|inv          # ignore help, etc as a value OR
                 |([a-zA-Z-]+\=               # ignore params as values OR
                 |$)))?)+)?                   # ignore last character spaces
    /x

    pattern   = /#{pat_param}#{pat_value}/

    # group the matches in an array
    results = param.scan(pattern)

    help_found = false

    if results.any?
      results.each {|result|
        row = {}

        if VALID_COMMANDS.include? result[0]

          case result[0]

            #------------------------------------------------------------------
            when "add"
            set_ingredients
            set_jarable_gems

            result[1] = result[1].sub(/\s+$/, "")

              gem_exists        = /#{@jarable_gems}/ =~ result[1]
              ingredient_exists = /#{@ingredients}/ =~ result[1]

              if (!CharSettings['whitelist'].include? result[1]) && (gem_exists || ingredient_exists)
                echo "Adding #{result[1]} to whitelist."
                CharSettings['whitelist'] << result[1]

              elsif CharSettings['whitelist'].include? result[1]
                echo "Item: #{result[1]} already in whitelist."
              else
                echo "Item: #{result[1]} is not a valid whitelist item."
              end

            #------------------------------------------------------------------
            when "remove"

              if CharSettings['whitelist'].include? result[1]
                echo "Removing #{result[1]} from whitelist."
                CharSettings['whitelist'].delete(result[1])
              end

            #------------------------------------------------------------------
            when "full-jar-bag"

              matched_bag = GameObj.inv.find{|container| %/#{result[1]}/ === "#{container.noun}"}

              if matched_bag
                echo "Setting your default full jar container to /#{result[1]}/"
                CharSettings['full_jar_bag'] = result[1]
              else
                echo "You must match the container NOUN, you entered: #{result[1]}"
              end

            #------------------------------------------------------------------
            when "combine-pearls"

              if /(true|false)/ =~ result[1]
                CharSettings['combine_pearls'] = result[1]
                echo "Combining pearls, set to: #{result[1]}"
              else
                echo "INVALID PARAMETER: You must use either 'true' or 'false'."
              end

            #------------------------------------------------------------------
            when "buy-empties"

              if /(true|false)/ =~ result[1]
                CharSettings['buy_empties'] = result[1]
                echo "Enabling buy empties mode."
              else
                echo "INVALID PARAMETER: You must use either 'true' or 'false'."
              end

            #------------------------------------------------------------------
            when "type-ahead"
              if /(:?[1-4])/ =~ result[1]
                CharSettings['type_ahead'] = result[1].to_i
                echo "Setting type ahead lines to (#{result[1]})"
              else
                echo "Invalid setting: Valid values are [1-4]."
              end

            #------------------------------------------------------------------
            when "list"
                get_user_vars

            #------------------------------------------------------------------
            when "help"
              help_found = true

            when "inv"
              @state = "inv"


          end


        else
          echo "Invalid command: #{result[0]}"
      end
      }

      if help_found
        get_help
      end

    end

    if !results.any?
      @state = "run"
    end

  end

  def get_help
    help_menu = []
    help_menu << "                                                            "
    help_menu << "Usage: run any of the commands below                        "
    help_menu << "                                                            "
    help_menu << " Adding and removing items to store                         "
    help_menu << "  \;#{@sn} add=(gem|ingredient)           { Adds item to whitelist to be stored in jars             }"
    help_menu << "  \;#{@sn} remove=(gem|ingredient)        { Removes item from the whitelist                         }"
    help_menu << "                                                            "
    help_menu << " Sorting features:                                          "
    help_menu << "  \;#{@sn} sort-fulls=(true|false)        { Not implemented                                         }"
    help_menu << "  \;#{@sn} combine-pearls=(true|false)    { Combine all pearl sizes in one jar, e.g., small/tiny    }"
    help_menu << "  \;#{@sn} full-jar-bag=(container)                         "
    help_menu << "                                                            "
    help_menu << " Inventory features:                                        "
    help_menu << "  \;#{@sn} inv                            { Displays jars in all containers and lockers. Provides a }"
    help_menu << "  \ \                                     { Total of all jars in each container/locker              }"
    help_menu << " Information commands:                                      "
    help_menu << "  \;#{@sn} help                           { Displays this menu                                      }"
    help_menu << "  \;#{@sn} list                           { Outputs a list of all your character variables          }"
    help_menu << "                                                            "
    help_menu.each do |item|
      respond "#{item}"
    end

  end

  def get_user_vars
    user_vars = []
    user_vars << "                                                            "
    user_vars << "Character Vars:                                             "
    user_vars << "  whitelist      = : #{CharSettings['whitelist'].sort}      "
    user_vars << "                                                            "
    user_vars << "  full-jar-bag   = : #{CharSettings['full_jar_bag']}        "
    user_vars << "  combine-pearls = : #{CharSettings['combine_pearls']}      "
    user_vars << "  type-ahead     = : #{CharSettings['type_ahead']}          "
    user_vars << "  buy-empties    = : #{CharSettings['buy_empties']}         "
    user_vars << "  premium        = : #{CharSettings['premium']}             "
    user_vars << "                                                            "
    user_vars.each do |item|
      respond "#{item}"
    end
  end

  def output_message(message, valid=nil)
    respond "#---------------------------------------------------------------#"
    respond "# #{message} ... #{valid}"
    respond "#---------------------------------------------------------------#"
  end

  private :process_params, :get_help
end

#------------------------------------------------------------------------------
# Jar processing facility, normalizes all whitelisted items and jars in
# inventory then fills all partially filled jars of that type then moves
# to empties

class JarHoarder

  LOCKERS = %w(teras sol river icemule zul ta'i ta'v mist)
  echo LOCKERS
  attr_reader :jars, :wants_stored, :inventory

  def initialize(whitelist, script_name)
    @scrip_name   = script_name
    @whitelist    = whitelist

    @jars         = {}
    @wants_stored = {}
    @in_hand_hash = {}
    @inventory    = {}

    # inventory instance vars

    @all_lockers  = []
    @grand_total  = {}

    set_subscription_level if CharSettings['premium'] == (nil || false)
  end

  def set_subscription_level
    sub_hash = {
        :a => /You are not currently a Premium subscriber/,
        :b => /As of your last logon/
    }

    stop_match = /\<prompt\stime\=/

    results = DownstreamHooks.auto_stop(stop_match,"premium start", "premie_check", false, sub_hash)

    if sub_hash[:b] =~ results[0].to_s
      CharSettings['premium'] = true
    else
      CharSettings['premium'] = false
    end

  end

  def clear_hands
    # put away anything that may be in your hands from global define container
    @in_hand_hash = {}  # hash table for items stored

    #----------------------------------------------------------------------------
    # check for sonic weapons

    if Spell[1012].active?
      put "stop 1012"
      echo "Stopping sonic weapon." if $debug == true
    end

    if Spell[1009].active?
      put "stop 1009"
      echo "Stopping sonic weapon." if $debug == true
    end

    #----------------------------------------------------------------------------
    # check for physical items

    if GameObj.right_hand.id
      echo "Putting away #{GameObj.right_hand}" if $debug == true
      @in_hand_hash.store(:right_hand, GameObj.right_hand.id)
      empty_right_hand
    end

    if GameObj.left_hand.id
      echo "Putting away #{GameObj.left_hand}" if $debug == true
      @in_hand_hash.store(:left_hand, GameObj.left_hand.id)
      empty_left_hand
    end

  end

  def named_capture_line(text_line, regex_hash)
    @hash_match = {}

    regex_hash.each_pair do |key, value|
      #------------------------------------------------------------------------
      # Recursive search through regex table.
      # if a match occurs in regex hash table, set match TRUE--stop checking

      if text_line =~ value
        # match was found
        @the_match     = value.match text_line # collect the match symbols
        @match_values  = @the_match.captures   # extract values, symbol table

        @named_regex   = value.named_captures  # named regex definitions
        @reg_captures  = @named_regex.count    # count number of named fields

        while @reg_captures > 0
          #------------------------------------------------------------------
          # builds the hash table to return with captured values and keys
          @hash_key                     = @named_regex.keys[(@reg_captures - 1)]
          @hash_value                   = @match_values[(@reg_captures - 1)]
          @hash_match[@hash_key.to_sym] = @hash_value

          @reg_captures -= 1
        end

        echo "MATCH OUTPUT HASH: #{@hash_match}" if $debug == true

        return @hash_match
      end
    end # end each p

    return nil
  end

  def run_command(command, match_hash)
    # runs a command, takes input hashtable of named regex, and returns
    # a single hash of the match and capture values

    @match_found = false                        # starts with no match

    @roundtime   = /(^\.\.\.wait\s(?<time>\d+)\sseconds\.$)|(^Wait\s(?<time>\d+)\sseconds.$)/

    fput "#{command}"                           # function input parameter

    echo "COMMAND ISSUED: #{command}" if $debug == true
    #--------------------------------------------------------------------------
    # keep checking each line on console

    while (!@match_found)

      @read_line = get                           # read console line

      if @read_line =~ @roundtime
        echo ">>>> Repeat command! FPUT Failed, again!" if $debug == true

        @rt_match  = @roundtime.match @read_line
        @cap_array = @rt_match.captures          # capture time, first named cap
        pause @cap_array[0].to_i                # pause in seconds

        fput "#{command}"                      # re-run command
      end


      @result = named_capture_line(@read_line, match_hash)

      if @result != nil
        @match_found = true
      else
        echo "NO MATCH: #{self} #{match_hash}" if $debug == true
      end

    end # end loop

    return @result
  end

  def set_locker_inventory

    # capture pattern for jars
    locker_jar = /(?:a|an)\s
      (?<name>[a-zA-Z\'\-\s]+(?:jar|bottle|beaker))\scontaining\s
      (?<item>[a-zA-Z\'\-\s]+)\s\s\(
      (?<amount>\d+)\/
      (?<limit>\d+)\)/x

    # blank these lines if they occur
    quiet = {
        :a => /Thinking back, you recall/,
        :b => /There are no items/
    }

    # stops the hook in XML
    stop_match = /\<prompt\stime\=/

    # hook needs a name to kill it
    hook_name  = "test_hook"

    @all_lockers    = [] # results of all jars in all lockers

    @grand_total    = {} # grand total results of all jars

    LOCKERS.each do |locker|

      jars_in_locker = {:id => locker, :jar_counts => [], :jar_totals => []}
      jar_totals     = {}

      #------------------------------------------------------------------------
      # start the hook

      DownstreamHooks.auto_stop(stop_match, "locker manifest #{locker}", hook_name,false, quiet)

      #------------------------------------------------------------------------
      # capture all console lines for each locker, break out when at the string
      # that signifies the end of the locker

      while line = get
        jar_hash       = {}
        if  line =~ locker_jar

          captures = locker_jar.match(line)

          jar_hash[:name]   = captures[:name]
          jar_hash[:item]   = captures[:item]
          jar_hash[:amount] = captures[:amount]
          jar_hash[:limit]  = captures[:limit]

          jars_in_locker[:jar_counts] << jar_hash

          # if the locker jar total item name doesn't exist create it and start a
          # count. If it exists, add to the count
          if jar_totals[jar_hash[:item]]
            jar_totals[jar_hash[:item]] += jar_hash[:amount].to_i
          else
            jar_totals[jar_hash[:item]] = jar_hash[:amount].to_i
          end

          # if the grand total item name doesn't exist create it and start a
          # count. If it exists, add to the count
          if @grand_total[jar_hash[:item]]
            @grand_total[jar_hash[:item]] += jar_hash[:amount].to_i
          else
            @grand_total[jar_hash[:item]] = jar_hash[:amount].to_i
          end

        end

        # end of the locker string match...add to that locker the jar list
        if line =~ /(?:Obvious\sitems|There are no items in this locker.)/
          jars_in_locker[:jar_totals] << jar_totals

          # all locker data frame
          @all_lockers << jars_in_locker
          break
        end

      end

    end

  end

  def get_locker_inventory
    # output per locker jars lists and each locker total, finally, output a grand total
    @all_lockers.each do |locker|

      # ignore lockers that are empty, and process the next
      next if !locker[:jar_counts].any?

      respond locker[:id].capitalize + "--------------"

      # output all jars and their counts
      locker[:jar_counts].each do |jar|
        respond "\(" + "#{jar[:amount]}".rjust(3) + "/"+ "#{jar[:limit]}m\)".rjust(5) + " #{jar[:item]}"
      end

      if locker[:jar_counts].any?
        respond "#{locker[:id].capitalize} Totals" + "---------------"
      end

      locker[:jar_totals][0].each_pair do |key, value|
        respond "(" + "#{value}):".rjust(5) + " #{key}"
      end

      respond ""

    end

    respond "GRAND TOTALS:" + "---------------"

    @grand_total.each_pair do |key, value|
      respond "(" + "#{value}):".rjust(6) + " #{key}"
    end

  end

  def set_inventory
    match_pattern     = /\s{6}(?:a|an)\s\<a\sexist\=\"
      (?<id>\d+)\"\snoun=\"
      (?<noun>[a-zA-Z\-\'\s]+)\"\>
      (?<name>[a-zA-Z\-\'\s]+)\<\/a\>(?:\r\n|\scontaining\s)
      ((?<contains>[a-zA-Z\s\-\']+)?(?:\r\n))?
    /x

    cont_pattern      = /^\s{2}(?:a|an)\s<a\sexist\=\"(?<noun>.*)/

    start_match       = /^You\sare\scurrently\swearing\sand\scarrying\:/
    stop_match        = /.*displayed.\)/
    job_complete      = false
    start             = false
    inventory_jars    = []
    non_matched_lines = []
    containers        = []

    DownstreamHook.add("inventory_count", Proc.new do |line|

      # squelch the empty lines
      if line.strip.length == 0
        nil
        next
      end

      if line =~ start_match
        start = true
      end


      # if the xml server line matches your intended stop text, close the hook
      if line =~ stop_match
        DownstreamHook.remove("inventory_count")
        job_complete = true
        nil

      else

        if (line =~ cont_pattern) && (start == true)
          containers << line
        end

        if (match_pattern =~ line) && (start == true)
          wants_hash = {}

          values = (match_pattern.match line).captures

          wants_hash[:id]       = values[0]
          wants_hash[:noun]     = values[1]
          wants_hash[:name]     = values[2]
          wants_hash[:contains] = values[3]


          if wants_hash[:noun] =~ /(?:jar|bottle|beaker)$/
            wants_hash[:contains] = values[3]
            inventory_jars.push(wants_hash)
          end


        else
          non_matched_lines << line
        end

        nil
      end


    end)
    silence_me

    put "inventory full containers"
    wait_until{job_complete}

    silence_me

    containers.each do |non_match|
      echo non_match
    end

  end

  def set_wants_stored(whitelist)
    @jars             = {}
    @wants_stored     = {}

    inventory_hashes  = []
    inventory_jars    = []
    non_matched_lines = []

    stop_match        = /.*displayed.\)/

    job_complete      = false

    match_pattern     = /\s{6}(?:a|an)\s\<a\sexist\=\"
      (?<id>\d+)\"\snoun=\"
      (?<noun>[a-zA-Z\-\'\s]+)\"\>
      (?<name>[a-zA-Z\-\'\s]+)\<\/a\>(?:\r\n|\scontaining\s)
      ((?<contains>[a-zA-Z\s\-\']+)?(?:\r\n))?
    /x


    DownstreamHook.add("normalize_inventory", Proc.new do |line|

      # squelch the empty lines
      if line.strip.length == 0
        nil
        next
      end

      # if the xml server line matches your intended stop text, close the hook
      if line =~ stop_match
        DownstreamHook.remove("normalize_inventory")
        job_complete = true
        nil

      else

        if match_pattern =~ line
          wants_hash = {}

          values = (match_pattern.match line).captures

          wants_hash[:id]       = values[0]
          wants_hash[:noun]     = values[1]
          wants_hash[:name]     = values[2]

          inventory_hashes.push(wants_hash)

          if wants_hash[:noun] =~ /(?:jar|bottle|beaker)$/
            wants_hash[:contains] = values[3]
            inventory_jars.push(wants_hash)
          end


        else
          non_matched_lines << line
        end

        nil
      end


    end)

    silence_me

    put "inventory full"
    wait_until{job_complete}

    silence_me

    #--------------------------------------------------------------------------
    # if flag set combine differentiating sizes in one jar

    if CharSettings['combine_pearls']

      chomp_pattern = /^(large\s|medium\s|small\s|tiny\s)\w+\spearl/

      inventory_hashes.each {|hash|

        if chomp_pattern  =~ hash[:name]
          hash[:name] = hash[:name].sub(/^(large\s|medium\s|small\s|tiny\s)/,"")
          echo "Item in bags cut into: #{hash[:name]}." if $debug == true
        end

      }

      count = 0

      whitelist.each{|item|

        if chomp_pattern =~ item
          echo "Found #{item} that needs to be cut..." if $debug == true
          whitelist[count] = item.sub(/^(large\s|medium\s|small\s|tiny\s)/,"")
          echo "Item in whitelist cut into: #{whitelist[count]}." if $debug == true
        end

        count += 1
      }

      # cut the large, medium, m

      inventory_jars.each {|hash|

        if chomp_pattern  =~ hash[:contains]
          hash[:contains] = hash[:contains].sub(/^(large\s|medium\s|small\s|tiny\s)/,"")
          echo "Found #{hash} that needs to be cut..."

        end
      }
    end

    # map all the gems that are whitelisted and in inventory
    inventory_hashes.each {|hash|

      if whitelist.include? hash[:name]
        if @wants_stored.key?(hash[:name])
          echo "Adding #{hash} to #{hash[:name]} hash" if $debug == true
          @wants_stored[hash[:name]] << hash
        else
          @wants_stored[hash[:name]] = []
          echo "No hash, making it: #{hash[:name]}" if $debug == true
          @wants_stored[hash[:name]] << hash
        end
      end

    }

    # map all the jars that are in inventory
    inventory_jars.each {|jar|

        if jar[:contains] == nil
          if @jars["empty"]               # if previous empties, add the next
            echo "Creating empty jar hash. Contains: #{jar[:contains]}" if $debug == true
            @jars["empty"] << jar
          else                            # no empty hash, make it
            @jars["empty"] = []
            echo "Add empty to \"empty\" hash. Contains: #{jar[:contains]}" if $debug == true
            @jars["empty"] << jar
          end

        else # non empty jars

          if @jars[jar[:contains]]        # if key of jar, add another jar
            echo "Add jar to hash (#{@jars[jar[:contains]]}). Contains: #{jar[:contains]}" if $debug == true
            @jars[jar[:contains]] << jar
          else                            # no key, make it
            @jars[jar[:contains]] = []
            echo "Add a new jar hash: #{jar[:contains]}" if $debug == true
            @jars[jar[:contains]] << jar
          end
        end
    }

    Script.current.want_downstream_xml = false
  end

  def process_wants(items_to_store = @wants_stored, jars_hashes = @jars)
    #You add an uncut emerald to the contents

    get_jar = {
      :got_it       => /^You\sremove\s(?:a|an)\s(?<contents>[a-zA-Z\-\s]+)\scontaining/,
      :full_hands   => /(?<hands_full>^You need a free hand)/,
      :missing      => /(?<missing>^I could not find what you referring to.)/,
      :empty        => /^You\sremove\s(?:a|an)\s(?<empty>[a-zA-Z\-\s]+)\sfrom in your/,
      :reach        => /^You\sreach\sinside\s(?<got_it>.*)/
    }

    get_item = {
      :got_it       => /^You\sremove\s(?:a|an)\s(?<item>[a-zA-Z\-\'\s]+)from/,

    }

    stow_item = {
      :stowed       => /^You\sput\s(?:a|an)\s(?<stowed>[a-zA-Z\-\s\']+)in your/,
      :wont_fit     => /^Your\s(?<wont_fit>.*won't\sfit)\sin/
    }

    fill_jar = {
      :full         => /^The\s(?<full>[a-zA-Z\-\'\s]+)is full!/,
      :filled       => /^You\sadd\s(?:a|an)\s[a-zA-Z\-\'\s]+\,\s(?<filled>filling\sit\.)/,
      :filling      => /^You\sadd\s(?:a|an)\s(?<filling>[a-zA-Z\-\'\s]+)to\sthe\scontents\sof\s[a-zA-Z\-\s]+\./,
      :empty        => /^You\sput\syour\s(?<filling>[a-zA-Z\s\'\-]+)\sinto\syour/,
      :not_held     => /^(?<not_held>You are not holding the jar.)/,
      :recharge     => /^(?<rechargable>[a-zA-Z\'\-\s]+)\sdoes\snot\s[a-z\s]+suitable/,
      :bad_mix      => /^The\s(?<wrong_type>[a-zA-Z\'\-\s]+already\scontains[a-zA-Z\'\-\s]+)\,/
    }

    #--------------------------------------------------------------------------
    #  Go through each items hash and store all list items

    for item_hash in items_to_store

      #------------------------------------------------------------------------
      # Items vars

      item_count              = item_hash[1].size
      item_name               = item_hash[0]
      item_list               = item_hash[1]

      partial_jars_to_process = false
      empty_jars_process      = false
      items_to_process        = true

      #------------------------------------------------------------------------
      # process one item list at a time, quit script unless set to auto-buy

      item_in_hand = false
      jar_in_hand  = false

      while items_to_process

        echo "Curent item(s) to process: #{item_name} count: #{item_count}" if $debug == true

        #----------------------------------------------------------------------
        #  Search for a matching...move to empty jars if none found

        for jar_hash in jars_hashes
          jar_name = jar_hash[0]
          jar_list = jar_hash[1]
          echo "item name: #{item_name} jar name: #{jar_name}" if $debug = true

          if /ruby/ =~ item_name
            pre_item = item_name
            item_name = item_name.sub(/ruby/, "rubies")
            echo "Need to make plural to match jar: change #{pre_item} to #{item_name}" if $debug == true
          end

          if /tooth/ =~ item_name
            pre_item = item_name
            item_name = item_name.sub(/tooth/, "teeth")
            echo "Need to make plural to match jar: change #{pre_item} to #{item_name}" if $debug == true
          end

          if /^#{item_name}/ =~ jar_name

              partial_jars_to_process = jar_list
              echo "Found a partial jars for #{item_name} partial list: #{partial_jars_to_process}" if $debug == true
              break
          end

        end # end find matching jars list

        #----------------------------------------------------------------------
        #  Try filling all jars of the same type first

        while partial_jars_to_process && items_to_process

          if item_list.any? && jar_list.any?

            if !item_in_hand
              current_item         = item_list[0]
              item_result = run_command("get ##{current_item[:id]}", get_item)
              item_in_hand = true
            end


            for jar in jar_list

              echo "entering partial jar in jars to process: #{jar[:id]}" if $debug == true

              if !jar_in_hand
                jar_result = run_command("get ##{jar[:id]}", get_jar)
              end

              echo "CURRENT JAR LIST: #{jar_list}" if $debug == true

              store_result = run_command("put ##{current_item[:id]} in ##{jar[:id]}", fill_jar)

              if store_result.keys == [:filling]
                item_in_hand = false
                echo "Pushed item: #{current_item[:name]} into jar: #{jar[:contains]}" if $debug == true
                item_list.delete(current_item)

                jar_in_hand = true
                echo "go get another item" if $debug == true
                break
              end

              if store_result.keys == [:filled]
                item_in_hand = false
                echo "Jar filled up, go get another..." if $debug == true

                if !CharSettings['full_jar_bag']
                  result = run_command("stow ##{jar[:id]}", stow_item)

                  if result.keys == [:wont_fit]
                    echo "Your default container is full. Clear your bags, or change container."
                    exit
                  end

                else
                  result = run_command("put ##{jar[:id]} in my #{CharSettings['full_jar_bag']}", stow_item)

                  if result.keys == [:wont_fit]
                    echo "Your #{CharSettings['full_jar_bag']} is full. Clear your bags, or change container."
                    exit
                  end
                end

                jar_in_hand = false
                jar_list.delete(jar)
                item_list.delete(current_item)
                echo "Jars left: #{jar_list}" if $debug == true
                break

              end

              if store_result.keys == [:full]
                item_in_hand = true

                echo "Jar was full, go get another..." if $debug == true

                if !CharSettings['full_jar_bag']
                  result = run_command("stow ##{jar[:id]}", stow_item)

                  if result.keys == [:wont_fit]
                    echo "Your default container is full. Clear your bags, or change container."
                    exit
                  end

                else
                  result = run_command("put ##{jar[:id]} in my #{CharSettings['full_jar_bag']}", stow_item)

                  if result.keys == [:wont_fit]
                    echo "Your #{CharSettings['full_jar_bag']} is full. Clear your bags, or change container."
                    exit
                  end

                end

                jar_in_hand = false
                jar_list.delete(jar)
                echo "Jars left: #{jar_list}" if $debug == true
                break
              end

              if store_result.keys == [:rechargable]
                echo "Possibly a rechargeable gem: #{current_item}, stowing..." if $debug == true
                run_command("stow ##{current_item[:id]}", stow_item)
                item_list.delete(current_item)
                item_in_hand = false
                jar_in_hand = true
                break
              end

              if store_result.keys == [:wrong_type]
                echo "Trying to combine wrong type: #{current_item}" if $debug == true
                run_command("stow ##{current_item[:id]}", stow_item)
                item_list.delete(current_item)
                item_in_hand = false
                jar_in_hand  = true
                break
              end

              partial_jars_to_process = false

              if jar_in_hand
                result = run_command("stow ##{jar[:id]}", stow_item)

                if result.keys == [:wont_fit]
                  echo "Your default container is full. Clear your bags, or change container."
                  exit
                end

              end

            end # end of for loop

          else # if either jars used up or items all put away

            if !item_list.any?
                items_to_process = false
                echo "used up all items" if $debug == true
            end

            if !jar_list.any?
                partial_jars_to_process = false

                echo "ran out of jars" if $debug == true
            end

            if jar_in_hand
              run_command("stow ##{jar[:id]}", stow_item)
            end

          end # end if items or jars
        end # end partials and items while loop

        #----------------------------------------------------------------------
        # If items not done and no partials check for empties

        if !partial_jars_to_process && items_to_process

          for jar_hash in jars_hashes
            jar_name = jar_hash[0]
            jar_list = jar_hash[1]

            if jar_name == "empty"
              empty_jars_process = jar_list
              echo "Found empties" if $debug == true
              break
            else
              empty_jars_process = false
            end

          end # end find matching jars list

          #----------------------------------------------------------------------
          #  Try filling all jars of the same type first

          while empty_jars_process && items_to_process

            if item_list.any? && jar_list.any?

              if !item_in_hand
                current_item         = item_list[0]
                item_result = run_command("get ##{current_item[:id]}", get_item)
                item_in_hand = true
              end

              for jar in jar_list
                echo "jar list: #{jar_list}" if $debug == true
                echo "entering jar in jars to process: #{jar[:id]}" if $debug == true

                if !jar_in_hand
                  jar_result = run_command("get ##{jar[:id]}", get_jar)
                end

                #--------------------------------------------------------------
                #  Run the command to put item in jar and check all
                #  possibilities

                store_result = run_command("put ##{current_item[:id]} in ##{jar[:id]}", fill_jar)

                if store_result.keys == [:filling]
                  item_in_hand = false
                  item_list.delete(current_item)

                  # check if you finished putting away all of same type
                  if !item_list.any?
                    jar_list.delete(jar)
                    run_command("stow ##{jar[:id]}", stow_item)
                    jar_in_hand = false
                    break
                  else
                    jar_in_hand = true
                    echo "go get another item" if $debug == true
                    break
                  end

                end

                # the jar is filled up, move to the next
                if store_result.keys == [:filled]
                  item_in_hand = false
                  echo "Jar filled up, go get another..." if $debug == true

                  if !CharSettings['full_jar_bag']
                    result = run_command("stow ##{jar[:id]}", stow_item)

                    if result.keys == [:wont_fit]
                      echo "Your default container is full. Clear your bags, or change container."
                      exit
                    end

                  else
                    result = run_command("put ##{jar[:id]} in my #{CharSettings['full_jar_bag']}", stow_item)

                    if result.keys == [:wont_fit]
                      echo "Your #{CharSettings['full_jar_bag']} is full. Clear your bags, or change container."
                      exit
                    end

                  end

                  jar_in_hand = false
                  jar_list.delete(jar)
                  break

                end

                # check if the jar you have is full, should never be a case
                if store_result.keys == [:full]
                  item_in_hand = true
                  item_list.delete(current_item)
                  echo "Jar was full, go get another..." if $debug == true

                  if !CharSettings['full_jar_bag']
                    result = run_command("stow ##{jar[:id]}", stow_item)

                    if result.keys == [:wont_fit]
                      echo "Your default container is full. Clear your bags, or change container."
                      exit
                    end

                  else
                    result = run_command("put ##{jar[:id]} in my #{CharSettings['full_jar_bag']}", stow_item)

                    if result.keys == [:wont_fit]
                      echo "Your #{CharSettings['full_jar_bag']} is full. Clear your bags, or change container."
                      exit
                    end

                  end

                  jar_in_hand = false
                  jar_list.delete(jar)
                  next
                end

                if store_result.keys == [:rechargable]
                  echo "Possibly a rechargeable gem: #{current_item}, stowing..." if $debug == true
                  run_command("stow ##{current_item[:id]}", stow_item)
                  item_in_hand = false
                  item_list.delete(current_item)
                  jar_in_hand = true
                  next
                end

                if store_result.keys == [:wrong_type]
                  echo "Trying to combine wrong type: #{current_item}" if $debug == true
                  run_command("stow ##{current_item[:id]}", stow_item)
                  item_list.delete(current_item)
                  item_in_hand = false
                  jar_in_hand  = true
                  break
                end

                #--------------------------------------------------------------
                # fail safe set jars left to false
                empty_jars_process = false

                if jar_in_hand
                  result = run_command("stow ##{jar[:id]}", stow_item)

                  if result.keys == [:wont_fit]
                    echo "Your default container is full. Clear your bags, or change container."
                    exit
                  end

                end

              end # end of for loop

            else # if either jars used up or items all put away

              if !item_list.any?
                items_to_process = false
                echo "used up all items" if $debug == true

              end

              if !jar_list.any?
                empty_jars_process = false
                jars_hashes.delete("empty")
                echo "ran out of jars" if $debug == true

              end

              if jar_in_hand
                result = run_command("stow ##{jar[:id]}", stow_item)

                if result.keys == [:wont_fit]
                  echo "Your default container is full. Clear your bags, or change container."
                  exit
                end

              end

              if item_in_hand
                run_command("stow ##{current_item[:id]}", stow_item)
              end

            end # end if items or jars
          end # end partials and items while loop

        end # end if to check for empties

        break
      end # end current item list processing while loop


    end # end main item hash lists for loop
  end

end

#------------------------------------------------------------------------------
# Runtime
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
#  Create the parameter parser object and sanatize the inputs

params      = Param_parser.new(script.vars, script.name)

#------------------------------------------------------------------------------
#  If in "run" mode, start the jar stashing process

case params.state
  when "run"
    # instantiate the jar handler object
    jar_handler = JarHoarder.new(whitelist, script.name)
    # clear hands if stuff in them
    jar_handler.clear_hands
    # determine if there's something that needs to be stored
    jar_handler.set_wants_stored(whitelist)
    # if something needs to be stored, process it
    jar_handler.process_wants

  when "inv"
    # instantiate the jar handler object
    jar_inv = JarHoarder.new(whitelist, script.name)

    jar_inv.set_locker_inventory

    jar_inv.get_locker_inventory

end

#------------------------------------------------------------------------------
# End Runtime
#------------------------------------------------------------------------------